class Compliance_Blocklist {
  _SAMPLE_RATE = 0.001
  _STAT_PREFIX = "compliance.blocklist."

  __construct :: ?array -> void
  __construct blocklists := {
    @blocklists = blocklists ?? DataType_Compliance_BlocklistType.getValues()
  }

  isPerformanceFeatureEnabled :: bool
  isPerformanceFeatureEnabled := @@is_performance_feature_enabled ||= ~product_compliance.blocklist_perf

  buildCompleteBlocklist :: ?array -> EP_Locale
  buildCompleteBlocklist blocklists loc := {
    locale = loc ?? EP_Locale.makeDefaultLocale()
    if ~product_compliance.blocklist_local_cache then {
      @@getLocallyCachedBlocklist(blocklists, locale)
    } else {
      @@getCachedBlocklist(blocklists, locale)
    }
  }

  buildLocalCacheKey :: ?array -> ?EP_Locale -> string
  buildLocalCacheKey blocklists loc := {
    locale_key = @@buildLocaleCacheComponent(loc ?? EP_Locale.makeDefaultLocale())

    if blocklists == null then {
      "allBlocklists" ++ locale_key
    } else {
      sort(blocklists)
      serialize(blocklists) ++ locale_key
    }
  }

  buildLocaleCacheComponent :: EP_Locale -> string
  buildLocaleCacheComponent loc := loc.getLanguage() ++ "|" ++ loc.getRegion()

  // Retrieves locally cached, complete blocklist (including stems)
  getLocallyCachedBlocklist :: ?array -> ?EP_Locale -> array
  @@getLocallyCachedBlocklist blocklists loc := {
    locale = loc ?? EP_Locale.makeDefaultLocale()
    localCacheKey = @@buildLocalCacheKey(blocklists, loc)
    @@locally_cached_blocklist[localCacheKey] ||= @@getCachedBlocklist(blocklists, loc)
  }

  @@clearLocalCache := @@locally_cached_blocklist = []

  @@buildStemmedBlocklist :: ?array -> ?EP_Locale
  @@buildStemmedBlocklist blocklists locale := {
    locale = loc ?? EP_Locale.makeDefaultLocale()
    timer = new Dev_Timer()
    blocklistTermFinder = EtsyORM.getFinder("Compliance_BlocklistedTerm")
    blocklistTerms = blocklistTermFinder.findAllByBlocklists(blocklists, loc)

    stemmed = []
    unstemmed = []
    word_counts = []
    stemmedIdMap = []

    if @@isPerformanceFeatureEnabled() then {
      stemmedIdMap[:blocklistTerm.blocklist_term_id] = :blocklistTerm.term

      if :blocklistTerm.is_stem then {
        # normalized = (new RichString(:blocklistTerm.term)).toArrayOfStemmedStrings()
        # normalized = (new RichString(:blocklistTerm.term))
        foo = (new Bar()).baz
        foo = (new Bar()).baz()
        words = array_unique(array_merge(explode(@@WORD_SEPARATOR, :blocklistTerm.term), normalized))
        word_counts[:blocklistTerm.blocklist_term_id] = count(normalized)
      } else {
        unstemmed []= :blocklistTerm.term
      }
    }

    @@timing("build_blocklist", timer)

    return {
      stemmed: stemmed,
      unstemmed: unstemmed,
      word_counts: word_counts,
    }

    }
}
